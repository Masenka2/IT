discovered_devices = discover_devices() //поиск устройств
10:51:58	
target_device = "Raj" 
target_device_address = None 

for address in discovered_devices: 
if target_device==lookup_name(address): 
target_device_address=address 
break
преобразование в нормальное имя
if target_device_address is not None: 
print "Адрес целевого устройства :", 
target_device_address 
else: 
print "Не могу найти адрес целевого устройства"
Код перебирает список адресов и передает один адрес в lookup_name способ. 
Затем он сравнивает возвращенное имя с имя нужного устройства. если они совпадают, то сообщение печатается и метод прерывает цикл.


Что завершает основные шаги, необходимые для подключения к любому устройству. 
Как только открытие сделано, то на основе типа услуги, связь может начаться. Теперь, когда шаги очевидны, давайте рассмотрим реальный 
пример, который использует шаги, только полная получить доступ к устройству Bluetooth.
from bluetooth import *
Далее идет класс с конструктором. Конструктор принимает имя устройства, адрес которого должен быть найден.
class Devices:
   def __init__( self, target_device_name):
      self.target_device=target_device_name
      self.target_device_address= None
      Далее определим метод, который будет выполнять поиск метода. 
      Если целевое устройство не найдено, это будет адрес переменной самостоятельно.target_device_address. 
      Найти адрес, он перебирает список адресов, возвращаемых discover_devices() метод и передает каждое обращение к lookup_name способ.
      def check_devices(self):
      discovered_devices=discover_devices()
      for address in discovered_devices:
        if self.target_device==lookup_name(address):
        self.target_device_address=address
        break
        Далее идет метод, который проверяет, соответствует ли адрес целевого устройства или нет. 
        Если найден, он будет возвращать адрес; в противном случае он вернет None.
         def device_found(self):
      self.check_devices()

       if self.target_device_address is not None:
        return self.target_device_address
      else:
        return None
       Это завершает наш класс. Теперь давайте проверить его, позвонив с другого модуля. 
       Модуль сначала попросить пользователя ввести имя устройства, которое будет обнаружено. 
       Тогда он будет создавать объект класса устройств и вызова метода check_device. 
       Возвращаемый результат будет отображаться для пользователя. Вот код:
       user_device= raw_input("Enter the device to be
discovered:")
device = Devices(user_device)
addr = device.device_found()

if addr is not None:
      print "адрес ус :". Adder
else:
      print "не могу найти адрес"
      Это завершатройствает наше обсуждение Основы программирования Bluetooth с помощью питона. 
      Следующий шаг-создайте и откройте для себя услуги. Это будет темой моего следующего обсуждения. До сих пор....
      
      
      
      
      
      
      
      
      
      а. Создание сокета сервера:

Первый шаг-это создать сокет, который будет слушать и принимать входящие запросы и создает подключение. 
Розетки можно было бы использовать при работе с протокол rfcomm, розетки и Bluetooth. 
Для создания Bluetooth-сокетов, BluetoothSocket должен именоваться используемый протокол. 
В данном случае это протокол rfcomm. Так, для того, чтобы создать сокет имени server_socket заявление будет:
server_socket= Bluetooth.BluetoothSocket(Bluetooth.RFCOMM)
Этот оператор создает только простой Bluetooth основанный сокет, который использует протокол rfcomm для общения. Следующие три шага сделать сокет сервера.

б. Привязка к порту:

Это второй шаг, чтобы сделать простой розетки работать сокет сервера. 
Объект сокета должен быть привязан к адресу и порту, так что он может начать прослушивает запросы. 
Однако, поскольку разъем будет связывать по Bluetooth, IP-адрес не требуется. PyBluez будет использовать адрес устройства, 
на котором он работает. Если устройство настольного ПК, тогда адрес будет соответствовать адресу, указанному bluetooth-адаптер. 
Чтобы привязать объект сокета к порту, привязать() метод должен б призвали объект сокета. 
Переданный аргумент-кортеж, содержащий адреса и порта нет. с какой сокет будет привязан. 
Например, чтобы привязать сокет к порту, скажем 11, заявление будет
server_socket.bind((“”,11))
Один пункт, чтобы иметь в виду при работе с rfcomm представляет, что rfcomm использует порты от 1-30 только.


с. Прослушивает запросы:

После того, как сокет был привязан к порту, следующим шагом будет его прослушивать

входящие запросы. 
Для этого, слушать() метод должен быть вызван на объект сокета. 
Слушать() метод не принимает. запросы должны храниться в очереди в качестве аргумента. 
Например, чтобы начать исполнение слушаю с очередью размером 3, заявление будет
server_socket.listen(3)
д. Принимая запросы:

После получения запроса, он должен быть принят так, что общение может начаться. 
Для этого нужно вызвать метод Accept() для объекта сокета. Метод Accept() не имеет аргументов. 
Он возвращает кортеж, содержащий адрес клиента и объекта сокета, через который дальнейшее общение может быть сделано. 
Так что утверждение, чтобы принять соединение
client_socket,address=server_socket.accept()
электронная. Передача/прием данных:

Последним шагом является отправка и/или получение данных. 
Если сервер на настольный ПК или обычный ПК, а затем отправлять и получать можно сделать с помощью библиотеки Python. 
Однако, если сервер на смартфон, тогда библиотека будет на основе операционной системы смартфона. 
Для обычного ПК, можно было бы вызвать Send() и вызовов recv() методы объекта сокета, возвращенный метод Accept ().
Как принимать строку в качестве аргумента. Например, если сервер хочет послать сообщение сказать, “привет”, код будет
client_socket.send(“Hello from server”)
